#!/usr/bin/env luajit

--[[
  lint_docs - A linter for markdown, text, and extensionless files

  Features:
  - Text wrapping at configurable line width (80 or 100)
  - Markdown table formatting with alignment rules
  - Table splitting for wide tables (first column repeated)
  - Preserves code blocks, headers

  Usage (CLI):     ./lint_docs <file_path>
  Usage (LLM):     echo '{"filename": "doc.md"}' | ./lint_docs

  Configuration is loaded from chat_config.lua (linter section):
    config.linter = {
        line_width = 80,
        file_extensions = {".md", ".txt", ""},
        table = { cell_padding = 1 },
    }
]]

local script_dir = arg[0]:match("(.*/)") or "./"

-- Add libs to package path (script is in libs/fuzzy-computing/tools/)
package.path = script_dir .. "../../?.lua;" ..  -- libs/ for dkjson
               script_dir .. "../?.lua;" ..      -- fuzzy-computing/ for config_loader
               package.path

local json = require("dkjson")
local config_loader = require("chat_config_loader")

-- Tool metadata for LLM discovery
local tool_info = {
    name = "lint_docs",
    description = "Format and lint markdown (.md) and text (.txt) files. " ..
                  "Wraps text at the configured line width, formats markdown tables " ..
                  "with proper alignment (first column right-justified, middle centered, " ..
                  "last column left-justified), and splits wide tables into multiple tables " ..
                  "with the ID column repeated. Use this to clean up documentation files.",
    parameters = {
        type = "object",
        properties = {
            filename = {
                type = "string",
                description = "The path to the file to lint (e.g., 'docs/readme.md', 'notes.txt')"
            }
        },
        required = {"filename"}
    }
}

-- Handle --tool-info flag
if arg[1] == "--tool-info" then
    print(json.encode(tool_info))
    os.exit(0)
end

-- Default linter configuration (fallback if not in chat_config)
local DEFAULT_LINTER_CONFIG = {
    line_width = 80,
    file_extensions = {".md", ".txt", ""},
    table = {
        cell_padding = 1,
    },
}

-- Deep merge tables
local function merge_tables(base, override)
    local result = {}
    for k, v in pairs(base) do
        if type(v) == "table" then
            result[k] = merge_tables(v, override[k] or {})
        else
            result[k] = override[k] ~= nil and override[k] or v
        end
    end
    for k, v in pairs(override) do
        if result[k] == nil then
            result[k] = v
        end
    end
    return result
end

-- Load configuration from chatbot config
local function load_config(file_path)
    local dir = file_path:match("(.*/)") or "./"
    local chat_config = config_loader.load(dir)

    -- Use linter section from chat_config, merged with defaults
    local linter_config = chat_config.linter or {}
    return merge_tables(DEFAULT_LINTER_CONFIG, linter_config)
end

-- Check if file should be processed
local function should_process(file_path, config)
    local ext = file_path:match("%.([^%./]+)$")
    if ext then ext = "." .. ext else ext = "" end

    for _, allowed in ipairs(config.file_extensions) do
        if ext == allowed then return true end
    end
    return false
end

-- Parse file into blocks
local function parse_into_blocks(lines)
    local blocks = {}
    local i = 1

    while i <= #lines do
        local line = lines[i]

        -- Check for fenced code block start
        if line:match("^%s*```") then
            local block = {type = "code", lines = {line}}
            i = i + 1
            while i <= #lines and not lines[i]:match("^%s*```") do
                table.insert(block.lines, lines[i])
                i = i + 1
            end
            if i <= #lines then
                table.insert(block.lines, lines[i])
                i = i + 1
            end
            table.insert(blocks, block)

        -- Check for table row
        elseif line:match("^%s*|") then
            local block = {type = "table", lines = {}}
            while i <= #lines and lines[i]:match("^%s*|") do
                table.insert(block.lines, lines[i])
                i = i + 1
            end
            table.insert(blocks, block)

        -- Check for header
        elseif line:match("^#+%s") or line:match("^#+$") then
            table.insert(blocks, {type = "header", lines = {line}})
            i = i + 1

        -- Check for blank line
        elseif line:match("^%s*$") then
            table.insert(blocks, {type = "blank", lines = {line}})
            i = i + 1

        -- Check for list item
        elseif line:match("^%s*[-*+]%s") or line:match("^%s*%d+%.%s") then
            local block = {type = "list_item", lines = {line}}
            local base_indent = #(line:match("^(%s*)") or "")
            i = i + 1
            -- Continue if next line is a continuation (more indented, not a new list item)
            while i <= #lines do
                local next_line = lines[i]
                local next_indent = #(next_line:match("^(%s*)") or "")
                -- Break on blank, new list item at same/less indent, or non-indented line
                if next_line:match("^%s*$") then break end
                if next_line:match("^%s*[-*+]%s") or next_line:match("^%s*%d+%.%s") then break end
                if next_indent <= base_indent and not next_line:match("^%s+") then break end
                if next_indent <= base_indent then break end
                table.insert(block.lines, next_line)
                i = i + 1
            end
            table.insert(blocks, block)

        -- Paragraph
        else
            local block = {type = "paragraph", lines = {}}
            while i <= #lines do
                local l = lines[i]
                if l:match("^%s*$") then break end
                if l:match("^%s*```") then break end
                if l:match("^%s*|") then break end
                if l:match("^#+%s") or l:match("^#+$") then break end
                if l:match("^%s*[-*+]%s") then break end
                if l:match("^%s*%d+%.%s") then break end
                table.insert(block.lines, l)
                i = i + 1
            end
            if #block.lines > 0 then
                table.insert(blocks, block)
            end
        end
    end

    return blocks
end

-- Wrap text at specified width
local function wrap_text(text, max_width)
    local words = {}
    for word in text:gmatch("%S+") do
        table.insert(words, word)
    end

    if #words == 0 then return {} end

    local lines = {}
    local current_line = ""

    for _, word in ipairs(words) do
        if current_line == "" then
            current_line = word
        elseif #current_line + 1 + #word <= max_width then
            current_line = current_line .. " " .. word
        else
            table.insert(lines, current_line)
            current_line = word
        end
    end

    if current_line ~= "" then
        table.insert(lines, current_line)
    end

    return lines
end

-- Wrap a paragraph block
local function wrap_paragraph(block, max_width)
    local text = table.concat(block.lines, " ")
    text = text:gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "")
    return wrap_text(text, max_width)
end

-- Wrap a list item block
local function wrap_list_item(block, max_width)
    local first_line = block.lines[1]
    local indent, marker, content = first_line:match("^(%s*)([-*+]%s+)(.*)")
    if not indent then
        indent, marker, content = first_line:match("^(%s*)(%d+%.%s+)(.*)")
    end
    if not indent then
        return block.lines
    end

    -- Collect all content
    local all_content = content
    for j = 2, #block.lines do
        all_content = all_content .. " " .. block.lines[j]:gsub("^%s+", "")
    end
    all_content = all_content:gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "")

    -- Calculate available width for content
    local prefix_len = #indent + #marker
    local content_width = max_width - prefix_len
    if content_width < 20 then content_width = 20 end

    -- Wrap content
    local wrapped = wrap_text(all_content, content_width)

    -- Build result
    local result = {}
    local continuation_indent = indent .. string.rep(" ", #marker)
    for k, line in ipairs(wrapped) do
        if k == 1 then
            table.insert(result, indent .. marker .. line)
        else
            table.insert(result, continuation_indent .. line)
        end
    end

    return result
end

-- Extract first column values from table lines (for comparison)
local function get_first_column_values(lines)
    local values = {}
    for _, line in ipairs(lines) do
        line = line:gsub("^%s+", ""):gsub("%s+$", "")
        local content = line:gsub("^|", ""):gsub("|$", "")
        -- Skip separator rows
        if not (content:match("^[-%s:|]+$") and content:match("%-")) then
            -- Get first cell
            local first_cell = content:match("^([^|]*)")
            if first_cell then
                table.insert(values, (first_cell:gsub("^%s+", ""):gsub("%s+$", "")))
            end
        end
    end
    return values
end

-- Check if two arrays are equal
local function arrays_equal(a, b)
    if #a ~= #b then return false end
    for i = 1, #a do
        if a[i] ~= b[i] then return false end
    end
    return true
end

-- Merge two parsed table row structures (combines columns, skipping duplicate first column)
local function merge_table_rows(rows1, rows2)
    local merged = {}

    -- First, figure out how many columns we'll have
    local cols1 = 0
    local cols2 = 0
    for _, row in ipairs(rows1) do
        if row.type == "data" and row.cells then
            cols1 = math.max(cols1, #row.cells)
        end
    end
    for _, row in ipairs(rows2) do
        if row.type == "data" and row.cells then
            cols2 = math.max(cols2, #row.cells)
        end
    end
    local total_cols = cols1 + cols2 - 1  -- -1 because we skip the duplicate first column

    for i, row1 in ipairs(rows1) do
        local row2 = rows2[i]
        if row1.type == "separator" then
            table.insert(merged, {type = "separator", num_cols = total_cols})
        elseif row1.type == "data" and row2 and row2.type == "data" then
            local new_cells = {}
            -- Copy all cells from first table
            for _, cell in ipairs(row1.cells) do
                table.insert(new_cells, cell)
            end
            -- Append cells from second table, skipping the first column (duplicate ID)
            for j = 2, #row2.cells do
                table.insert(new_cells, row2.cells[j])
            end
            table.insert(merged, {type = "data", cells = new_cells})
        elseif row1.type == "data" then
            -- row2 might be separator or missing
            table.insert(merged, row1)
        end
    end

    return merged
end

-- Convert parsed rows back to table lines
local function rows_to_lines(rows)
    local lines = {}
    for _, row in ipairs(rows) do
        if row.type == "separator" then
            local parts = {}
            for i = 1, #row.cells or 1 do
                table.insert(parts, "---")
            end
            -- Use a simple separator that will be reformatted later
            table.insert(lines, "|---|")
        else
            local parts = {}
            for _, cell in ipairs(row.cells) do
                table.insert(parts, cell)
            end
            table.insert(lines, "|" .. table.concat(parts, "|") .. "|")
        end
    end
    return lines
end

-- Pre-process blocks to recombine previously split tables
local function recombine_split_tables(blocks)
    local result = {}
    local i = 1

    while i <= #blocks do
        local block = blocks[i]

        if block.type == "table" then
            -- Look ahead for pattern: table, blank, table with same first column
            local combined_rows = nil
            local current_lines = block.lines

            while true do
                -- Check if next is blank followed by table
                if i + 2 <= #blocks and
                   blocks[i + 1].type == "blank" and
                   blocks[i + 2].type == "table" then

                    local next_table_lines = blocks[i + 2].lines

                    -- Get first column values from both tables
                    local first_col_1 = get_first_column_values(current_lines)
                    local first_col_2 = get_first_column_values(next_table_lines)

                    -- Check if first columns match
                    if arrays_equal(first_col_1, first_col_2) then
                        -- Parse both tables
                        local rows1 = (parse_table or function() end)(current_lines)
                        local rows2 = (parse_table or function() end)(next_table_lines)

                        -- We need parse_table to exist - it's defined below
                        -- So we'll do inline parsing here
                        local function quick_parse(lines)
                            local rows = {}
                            for _, line in ipairs(lines) do
                                line = line:gsub("^%s+", ""):gsub("%s+$", "")
                                local content = line:gsub("^|", ""):gsub("|$", "")
                                if content:match("^[-%s:|]+$") and content:match("%-") then
                                    table.insert(rows, {type = "separator"})
                                else
                                    local cells = {}
                                    for cell in (content .. "|"):gmatch("([^|]*)|") do
                                        cell = cell:gsub("^%s+", ""):gsub("%s+$", "")
                                        -- Strip markdown (bold/italic/code)
                                        cell = cell:gsub("%*%*(.-)%*%*", "%1"):gsub("__(.-)__", "%1")
                                        cell = cell:gsub("%*(.-)%*", "%1"):gsub("_(.-)_", "%1")
                                        cell = cell:gsub("`(.-)`", "%1")
                                        table.insert(cells, cell)
                                    end
                                    table.insert(rows, {type = "data", cells = cells})
                                end
                            end
                            return rows
                        end

                        rows1 = quick_parse(current_lines)
                        rows2 = quick_parse(next_table_lines)

                        -- Merge the tables
                        local merged = merge_table_rows(rows1, rows2)

                        -- Convert back to lines
                        local merged_lines = {}
                        for _, row in ipairs(merged) do
                            if row.type == "separator" then
                                local sep_parts = {}
                                for _ = 1, (row.num_cols or 1) do
                                    table.insert(sep_parts, "---")
                                end
                                table.insert(merged_lines, "|" .. table.concat(sep_parts, "|") .. "|")
                            else
                                table.insert(merged_lines, "|" .. table.concat(row.cells, "|") .. "|")
                            end
                        end

                        current_lines = merged_lines
                        i = i + 2  -- Skip the blank and the merged table
                    else
                        break  -- First columns don't match, stop merging
                    end
                else
                    break  -- No more table, blank, table pattern
                end
            end

            table.insert(result, {type = "table", lines = current_lines})
            i = i + 1
        else
            table.insert(result, block)
            i = i + 1
        end
    end

    return result
end

-- Strip markdown formatting from text (bold, italic, code)
local function strip_markdown(text)
    -- Strip bold (**text** or __text__)
    text = text:gsub("%*%*(.-)%*%*", "%1")
    text = text:gsub("__(.-)__", "%1")
    -- Strip italic (*text* or _text_) - be careful not to match already-stripped bold
    text = text:gsub("%*(.-)%*", "%1")
    text = text:gsub("_(.-)_", "%1")
    -- Strip inline code (`text`)
    text = text:gsub("`(.-)`", "%1")
    return text
end

-- Parse table into rows
local function parse_table(lines)
    local rows = {}
    local max_cols = 0

    for _, line in ipairs(lines) do
        -- Remove leading/trailing whitespace
        line = line:gsub("^%s+", ""):gsub("%s+$", "")
        -- Remove leading/trailing |
        local content = line:gsub("^|", ""):gsub("|$", "")

        -- Check if separator row
        if content:match("^[-%s:|]+$") and content:match("%-") then
            table.insert(rows, {type = "separator", raw = line})
        else
            -- Split by | (handle escaped \|)
            local cells = {}
            local current = ""
            local j = 1
            while j <= #content do
                local c = content:sub(j, j)
                if c == "\\" and content:sub(j+1, j+1) == "|" then
                    current = current .. "|"
                    j = j + 2
                elseif c == "|" then
                    local cell = current:gsub("^%s+", ""):gsub("%s+$", "")
                    table.insert(cells, strip_markdown(cell))
                    current = ""
                    j = j + 1
                else
                    current = current .. c
                    j = j + 1
                end
            end
            local cell = current:gsub("^%s+", ""):gsub("%s+$", "")
            table.insert(cells, strip_markdown(cell))

            table.insert(rows, {type = "data", cells = cells})
            if #cells > max_cols then max_cols = #cells end
        end
    end

    -- Normalize: ensure all rows have same number of cells
    for _, row in ipairs(rows) do
        if row.type == "data" then
            while #row.cells < max_cols do
                table.insert(row.cells, "")
            end
        end
    end

    return rows, max_cols
end

-- Calculate column widths
local function calculate_column_widths(rows)
    local widths = {}

    for _, row in ipairs(rows) do
        if row.type == "data" then
            for i, cell in ipairs(row.cells) do
                widths[i] = math.max(widths[i] or 0, display_width(cell))
            end
        end
    end

    return widths
end

-- Calculate display width of a string (handles UTF-8 and emoji)
-- This attempts to match terminal display width for common characters
local function display_width(str)
    local width = 0
    local i = 1
    local len = #str
    local prev_was_regional = false  -- for flag emoji detection

    while i <= len do
        local byte = str:byte(i)

        if byte < 128 then
            -- ASCII: 1 byte, 1 width
            width = width + 1
            i = i + 1
            prev_was_regional = false

        elseif byte < 224 then
            -- 2-byte UTF-8 (U+0080-U+07FF): 1 width
            width = width + 1
            i = i + 2
            prev_was_regional = false

        elseif byte < 240 then
            -- 3-byte UTF-8 (U+0800-U+FFFF)
            -- Decode codepoint to check for special ranges
            local b2 = str:byte(i + 1) or 0
            local b3 = str:byte(i + 2) or 0
            local codepoint = ((byte - 224) * 4096) + ((b2 - 128) * 64) + (b3 - 128)

            if codepoint >= 0xFE00 and codepoint <= 0xFE0F then
                -- Variation selectors: 0 width (they modify previous char)
                -- Don't add width
            elseif codepoint == 0x200D then
                -- Zero-width joiner: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0300 and codepoint <= 0x036F) then
                -- Combining Diacritical Marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x093A and codepoint <= 0x094F) or
                   (codepoint >= 0x0951 and codepoint <= 0x0957) or
                   (codepoint >= 0x0962 and codepoint <= 0x0963) then
                -- Devanagari combining marks (matras, nukta, virama): 0 width
                -- Don't add width
            elseif (codepoint >= 0x09BE and codepoint <= 0x09CD) or
                   (codepoint >= 0x09E2 and codepoint <= 0x09E3) then
                -- Bengali combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0A3E and codepoint <= 0x0A4D) then
                -- Gurmukhi combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0ABE and codepoint <= 0x0ACD) then
                -- Gujarati combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0B3E and codepoint <= 0x0B4D) then
                -- Oriya combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0BBE and codepoint <= 0x0BCD) then
                -- Tamil combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0C3E and codepoint <= 0x0C4D) then
                -- Telugu combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0CBE and codepoint <= 0x0CCD) then
                -- Kannada combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0D3E and codepoint <= 0x0D4D) then
                -- Malayalam combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0591 and codepoint <= 0x05BD) or
                   (codepoint >= 0x05BF and codepoint <= 0x05C7) then
                -- Hebrew combining marks: 0 width
                -- Don't add width
            elseif (codepoint >= 0x0610 and codepoint <= 0x061A) or
                   (codepoint >= 0x064B and codepoint <= 0x065F) then
                -- Arabic combining marks: 0 width
                -- Don't add width
            elseif codepoint >= 0x1100 and codepoint <= 0x11FF then
                -- Hangul Jamo: 2 wide
                width = width + 2
            elseif codepoint >= 0x2E80 and codepoint <= 0x9FFF then
                -- CJK ranges: 2 wide
                width = width + 2
            elseif codepoint >= 0xAC00 and codepoint <= 0xD7AF then
                -- Hangul syllables: 2 wide
                width = width + 2
            elseif codepoint >= 0xF900 and codepoint <= 0xFAFF then
                -- CJK Compatibility Ideographs: 2 wide
                width = width + 2
            elseif codepoint >= 0xFF00 and codepoint <= 0xFFEF then
                -- Fullwidth forms: 2 wide
                width = width + 2
            elseif codepoint >= 0x2600 and codepoint <= 0x26FF then
                -- Miscellaneous Symbols (many emoji): 2 wide
                width = width + 2
            elseif codepoint >= 0x2700 and codepoint <= 0x27BF then
                -- Dingbats (many emoji): 2 wide
                width = width + 2
            elseif codepoint >= 0x2300 and codepoint <= 0x23FF then
                -- Miscellaneous Technical (some emoji): 2 wide
                width = width + 2
            elseif codepoint >= 0x2B50 and codepoint <= 0x2B55 then
                -- Some emoji stars/circles: 2 wide
                width = width + 2
            else
                -- Other 3-byte chars (most symbols like ★☆): 1 wide
                width = width + 1
            end
            i = i + 3
            prev_was_regional = false

        else
            -- 4-byte UTF-8 (U+10000+): includes most emoji
            -- Decode to check for regional indicators (flag emoji)
            local b2 = str:byte(i + 1) or 0
            local b3 = str:byte(i + 2) or 0
            local b4 = str:byte(i + 3) or 0
            local codepoint = ((byte - 240) * 262144) + ((b2 - 128) * 4096) +
                              ((b3 - 128) * 64) + (b4 - 128)

            if codepoint >= 0x1F1E6 and codepoint <= 0x1F1FF then
                -- Regional indicator symbols (flag emoji components)
                -- Two of these combine to form one flag (2 wide total)
                if prev_was_regional then
                    -- Second regional indicator - don't add width (already counted)
                    prev_was_regional = false
                else
                    -- First regional indicator - add 2 for the pair
                    width = width + 2
                    prev_was_regional = true
                end
            else
                -- Most other 4-byte chars (emoji): 2 wide
                width = width + 2
                prev_was_regional = false
            end
            i = i + 4
        end
    end
    return width
end

-- Format cell with alignment
local function format_cell(text, width, alignment)
    local padding = width - display_width(text)
    if padding < 0 then padding = 0 end

    if alignment == "left" then
        return text .. string.rep(" ", padding)
    elseif alignment == "right" then
        return string.rep(" ", padding) .. text
    else -- center
        local left_pad = math.floor(padding / 2)
        local right_pad = padding - left_pad
        return string.rep(" ", left_pad) .. text .. string.rep(" ", right_pad)
    end
end

-- Format a single table
local function format_single_table(rows, widths, cell_padding)
    local result = {}
    local num_cols = #widths

    for _, row in ipairs(rows) do
        if row.type == "separator" then
            local parts = {}
            for i = 1, num_cols do
                local dashes = string.rep("-", widths[i] + cell_padding * 2)
                parts[i] = dashes
            end
            table.insert(result, "|" .. table.concat(parts, "|") .. "|")
        else
            local parts = {}
            for i, cell in ipairs(row.cells) do
                if i > num_cols then break end

                local alignment
                if i == 1 then
                    alignment = "right"
                elseif i == num_cols then
                    alignment = "left"
                else
                    alignment = "center"
                end

                local formatted = format_cell(cell, widths[i], alignment)
                parts[i] = string.rep(" ", cell_padding) .. formatted .. string.rep(" ", cell_padding)
            end
            table.insert(result, "|" .. table.concat(parts, "|") .. "|")
        end
    end

    return result
end

-- Calculate table width from column widths
local function calculate_table_width(widths, cell_padding)
    local total = 1 -- opening |
    for _, w in ipairs(widths) do
        total = total + w + (cell_padding * 2) + 1 -- content + padding + |
    end
    return total
end

-- Wrap text to a target width at word boundaries, returning array of lines
local function wrap_text_to_width(text, target_width)
    if target_width < 5 then target_width = 5 end
    if #text <= target_width then
        return {text}
    end

    local lines = {}
    local words = {}
    for word in text:gmatch("%S+") do
        table.insert(words, word)
    end

    local current_line = ""
    for _, word in ipairs(words) do
        if current_line == "" then
            -- First word - if it's longer than target, we have to take it anyway
            current_line = word
        elseif #current_line + 1 + #word <= target_width then
            current_line = current_line .. " " .. word
        else
            table.insert(lines, current_line)
            current_line = word
        end
    end

    if current_line ~= "" then
        table.insert(lines, current_line)
    end

    return #lines > 0 and lines or {""}
end

-- Calculate target widths using "shrink largest first" strategy
-- This minimizes the number of columns that need wrapping
local function calculate_target_widths(natural_widths, max_width, cell_padding, min_wrap_width)
    min_wrap_width = min_wrap_width or 18  -- Minimum width for wrapped columns
    local num_cols = #natural_widths

    -- Calculate available content space
    local overhead = 1 + (num_cols * (cell_padding * 2 + 1))
    local available = max_width - overhead
    if available < num_cols * 5 then
        available = num_cols * 5  -- Absolute minimum
    end

    -- Start with all columns at natural width
    local allocated = {}
    local total = 0
    for i, w in ipairs(natural_widths) do
        allocated[i] = w
        total = total + w
    end

    -- If everything fits, we're done
    if total <= available then
        return allocated
    end

    -- Need to shrink - reduce largest columns first (minimizes wrap count)
    -- Only shrink columns that are "large" (> 15 chars) to avoid touching small ones
    local shrink_threshold = 15
    local min_after_shrink = 10  -- Don't shrink below this

    while total > available do
        -- Find the largest column that can be shrunk
        local max_idx = nil
        local max_val = 0
        for i = 1, num_cols do
            -- Can shrink if: large enough, above minimum, and was originally big
            if allocated[i] > min_after_shrink and
               natural_widths[i] > shrink_threshold and
               allocated[i] > max_val then
                max_idx = i
                max_val = allocated[i]
            end
        end

        if not max_idx then
            -- No large columns left to shrink - fall back to shrinking any column
            for i = 1, num_cols do
                if allocated[i] > min_after_shrink and allocated[i] > max_val then
                    max_idx = i
                    max_val = allocated[i]
                end
            end
        end

        if not max_idx then break end  -- Can't shrink anymore

        -- Shrink by amount needed, but not below minimum
        local need_to_save = total - available
        local can_shrink = allocated[max_idx] - min_after_shrink
        local shrink_amount = math.min(need_to_save, can_shrink)

        if shrink_amount <= 0 then break end

        allocated[max_idx] = allocated[max_idx] - shrink_amount
        total = total - shrink_amount
    end

    return allocated
end

-- Wrap cells in a table to fit target widths, filling continuation slots
-- Returns: output_rows, actual_widths, wrapped_cols (set of column indices that were wrapped)
local function wrap_table_to_targets(rows, natural_widths, target_widths, cell_padding)
    local num_cols = #natural_widths
    local wrapped_cols = {}  -- Track which columns have wrapped content

    -- Build output rows with wrapped content
    -- For each data row, we may create multiple output rows (main + continuations)
    local output_rows = {}
    local is_header = true  -- First data row is header

    for _, row in ipairs(rows) do
        if row.type == "separator" then
            table.insert(output_rows, {type = "separator"})
            is_header = false
        elseif row.type == "data" then
            local wrapped_cells = {}
            local max_lines = 1

            for i = 1, num_cols do
                local cell = row.cells[i] or ""
                -- Allow both headers and data to wrap if they exceed target width
                if natural_widths[i] <= target_widths[i] then
                    wrapped_cells[i] = {cell}
                else
                    -- For data cells, wrap to (target - 2) to leave room for continuation indent
                    -- Headers don't get indented, so they can use full target width
                    local wrap_width = is_header and target_widths[i] or math.max(target_widths[i] - 2, 5)
                    wrapped_cells[i] = wrap_text_to_width(cell, wrap_width)
                    if #wrapped_cells[i] > 1 then
                        wrapped_cols[i] = true  -- Mark this column as wrapped
                    end
                end
                max_lines = math.max(max_lines, #wrapped_cells[i])
            end

            -- Create main row and continuation rows
            for line_num = 1, max_lines do
                local new_row = {
                    type = line_num == 1 and "data" or "continuation",
                    cells = {}
                }
                for i = 1, num_cols do
                    local line = wrapped_cells[i][line_num] or ""
                    -- Add indent for continuation lines (but not for header continuations)
                    if line_num > 1 and line ~= "" and not is_header then
                        line = "  " .. line
                    end
                    new_row.cells[i] = line
                end
                table.insert(output_rows, new_row)
            end

            if is_header then is_header = false end
        end
    end

    -- Recalculate actual widths after wrapping
    local actual_widths = {}
    for i = 1, num_cols do
        actual_widths[i] = 0
    end
    for _, row in ipairs(output_rows) do
        if row.cells then
            for i, cell in ipairs(row.cells) do
                actual_widths[i] = math.max(actual_widths[i] or 0, display_width(cell))
            end
        end
    end

    return output_rows, actual_widths, wrapped_cols
end

-- Format rows into a table string
-- wrapped_cols is an optional set of column indices that should be left-justified
local function format_rows_to_table(rows, widths, cell_padding, wrapped_cols)
    wrapped_cols = wrapped_cols or {}
    local result = {}
    local num_cols = #widths
    local is_header = true  -- Track if we're before the separator (header row)

    for _, row in ipairs(rows) do
        if row.type == "separator" then
            local parts = {}
            for i = 1, num_cols do
                parts[i] = string.rep("-", widths[i] + cell_padding * 2)
            end
            table.insert(result, "|" .. table.concat(parts, "|") .. "|")
            is_header = false
        else
            local parts = {}
            for i = 1, num_cols do
                local cell = row.cells[i] or ""
                local alignment

                -- Wrapped columns are always left-justified so indent is visible
                if wrapped_cols[i] then
                    alignment = "left"
                elseif i == 1 then
                    -- First column: center header, right-justify data
                    alignment = is_header and "center" or "right"
                elseif i == num_cols then
                    alignment = "left"
                else
                    alignment = "center"
                end

                local formatted = format_cell(cell, widths[i], alignment)
                parts[i] = string.rep(" ", cell_padding) .. formatted .. string.rep(" ", cell_padding)
            end
            table.insert(result, "|" .. table.concat(parts, "|") .. "|")
        end
    end

    return result
end

-- Extract subset of columns from rows
local function extract_columns(rows, col_indices, num_cols)
    local sub_rows = {}
    for _, row in ipairs(rows) do
        if row.type == "separator" then
            table.insert(sub_rows, {type = "separator"})
        elseif row.type == "data" or row.type == "continuation" then
            -- Only include continuation rows if they have content
            local has_content = (row.type == "data")
            local new_cells = {}
            for _, col_idx in ipairs(col_indices) do
                local cell = row.cells[col_idx] or ""
                new_cells[#new_cells + 1] = cell
                if cell:match("%S") then has_content = true end
            end
            if has_content then
                table.insert(sub_rows, {type = row.type, cells = new_cells})
            end
        end
    end
    return sub_rows
end

-- Main table formatting function with smart wrapping and splitting
local function format_table_smart(rows, widths, max_width, cell_padding)
    local num_cols = #widths
    local total_width = calculate_table_width(widths, cell_padding)

    -- If table fits, format normally
    if total_width <= max_width then
        return {format_single_table(rows, widths, cell_padding)}
    end

    -- Calculate target widths with fair distribution
    local target_widths = calculate_target_widths(widths, max_width, cell_padding)

    -- Try wrapping to fit targets
    local wrapped_rows, actual_widths, wrapped_cols = wrap_table_to_targets(rows, widths, target_widths, cell_padding)
    local wrapped_width = calculate_table_width(actual_widths, cell_padding)

    -- Count how many columns were wrapped
    local num_wrapped = 0
    for _ in pairs(wrapped_cols) do
        num_wrapped = num_wrapped + 1
    end

    -- Only use wrapping if table fits AND we wrapped at most 2 columns
    -- If more than 2 columns need wrapping, split the table instead
    if wrapped_width <= max_width and num_wrapped <= 2 then
        return {format_rows_to_table(wrapped_rows, actual_widths, cell_padding, wrapped_cols)}
    end

    -- Split into sub-tables, trying to maximize columns per sub-table
    -- while respecting the 2-wrapped-column limit and max wrap lines
    local max_wrap_lines = 4    -- Don't wrap data cells to more than this many lines
    local max_header_lines = 2  -- Headers can only wrap to 2 lines max

    -- Extract header widths (first data row before separator)
    local header_widths = {}
    for _, row in ipairs(rows) do
        if row.type == "separator" then break end
        if row.type == "data" then
            for i, cell in ipairs(row.cells) do
                header_widths[i] = display_width(cell)
            end
            break
        end
    end

    local sub_tables = {}
    local remaining_cols = {}
    for i = 2, num_cols do
        table.insert(remaining_cols, i)
    end

    while #remaining_cols > 0 do
        local current_cols = {1}
        local cols_added = {}

        -- Try to add columns, checking both natural and wrapped fits
        for _, col_idx in ipairs(remaining_cols) do
            -- Build test column set
            local test_cols = {}
            for _, c in ipairs(current_cols) do
                table.insert(test_cols, c)
            end
            table.insert(test_cols, col_idx)

            -- Get natural widths for test set
            local test_natural = {}
            for j, c in ipairs(test_cols) do
                test_natural[j] = widths[c]
            end

            -- Check if fits at natural widths
            local test_natural_width = calculate_table_width(test_natural, cell_padding)
            if test_natural_width <= max_width then
                -- Fits at natural widths - add it
                table.insert(current_cols, col_idx)
                table.insert(cols_added, col_idx)
            else
                -- Doesn't fit naturally - check if fits with wrapping
                local test_targets = calculate_target_widths(test_natural, max_width, cell_padding)
                local test_target_width = calculate_table_width(test_targets, cell_padding)

                -- Count how many columns would need wrapping and estimate max lines
                local would_wrap = 0
                local max_lines = 1
                local max_hdr_lines = 1
                for j = 1, #test_natural do
                    if test_natural[j] > test_targets[j] then
                        would_wrap = would_wrap + 1
                        -- Estimate lines needed for data (content / target width, rounded up)
                        local est_lines = math.ceil(test_natural[j] / test_targets[j])
                        if est_lines > max_lines then
                            max_lines = est_lines
                        end
                    end
                    -- Check header wrap lines separately
                    local col_idx = test_cols[j]
                    local hdr_width = header_widths[col_idx] or 0
                    if hdr_width > test_targets[j] then
                        local hdr_lines = math.ceil(hdr_width / test_targets[j])
                        if hdr_lines > max_hdr_lines then
                            max_hdr_lines = hdr_lines
                        end
                    end
                end

                -- Accept if: fits, ≤2 wrapped cols, ≤4 data lines, ≤2 header lines (or only 2 cols)
                local lines_ok = max_lines <= max_wrap_lines or #test_cols <= 2
                local hdr_ok = max_hdr_lines <= max_header_lines or #test_cols <= 2
                if test_target_width <= max_width and would_wrap <= 2 and lines_ok and hdr_ok then
                    -- Can fit with wrapping, within limits
                    table.insert(current_cols, col_idx)
                    table.insert(cols_added, col_idx)
                else
                    -- Can't fit, or would exceed wrap/lines limit
                    break
                end
            end
        end

        -- If no columns were added, force add the next one (unlimited lines allowed)
        if #cols_added == 0 and #remaining_cols > 0 then
            local col_idx = remaining_cols[1]
            table.insert(current_cols, col_idx)
            table.insert(cols_added, col_idx)
        end

        -- Format this sub-table
        local sub_rows = extract_columns(rows, current_cols, num_cols)
        local sub_natural = {}
        for j, col_idx in ipairs(current_cols) do
            sub_natural[j] = widths[col_idx]
        end

        local sub_natural_width = calculate_table_width(sub_natural, cell_padding)
        if sub_natural_width <= max_width then
            -- Fits at natural widths
            table.insert(sub_tables, format_rows_to_table(sub_rows, sub_natural, cell_padding, {}))
        else
            -- Needs wrapping
            local sub_targets = calculate_target_widths(sub_natural, max_width, cell_padding)
            local sub_wrapped, sub_actual, sub_wrapped_cols = wrap_table_to_targets(sub_rows, sub_natural, sub_targets, cell_padding)
            table.insert(sub_tables, format_rows_to_table(sub_wrapped, sub_actual, cell_padding, sub_wrapped_cols))
        end

        -- Remove added columns from remaining
        local new_remaining = {}
        local added_set = {}
        for _, c in ipairs(cols_added) do added_set[c] = true end
        for _, c in ipairs(remaining_cols) do
            if not added_set[c] then
                table.insert(new_remaining, c)
            end
        end
        remaining_cols = new_remaining
    end

    return sub_tables
end

-- Legacy function for compatibility
local function split_table_if_needed(rows, widths, max_width, cell_padding)
    return format_table_smart(rows, widths, max_width, cell_padding)
end

-- Process table block
local function process_table(lines, config)
    local rows, max_cols = parse_table(lines)
    if max_cols == 0 then return lines end

    local widths = calculate_column_widths(rows)
    local cell_padding = config.table.cell_padding

    local sub_tables = split_table_if_needed(rows, widths, config.line_width, cell_padding)

    local result = {}
    for idx, sub_table in ipairs(sub_tables) do
        if idx > 1 then
            table.insert(result, "")
        end
        for _, line in ipairs(sub_table) do
            table.insert(result, line)
        end
    end

    return result
end

-- Core linting function (returns success, result_or_error, stats)
local function lint_file(file_path, project_dir)
    project_dir = project_dir or "./"

    -- Build full path if relative
    local full_path = file_path
    if not file_path:match("^/") then
        full_path = project_dir .. "/" .. file_path
    end

    local config = load_config(full_path)

    -- Check extension
    if not should_process(full_path, config) then
        return false, "File extension not in allowed list (use .md, .txt, or no extension)"
    end

    -- Read file
    local f = io.open(full_path, "r")
    if not f then
        return false, "Cannot open file: " .. full_path
    end

    local content = f:read("*a")
    f:close()

    local original_size = #content
    local original_lines = select(2, content:gsub("\n", "\n")) + 1

    -- Parse into lines
    local lines = {}
    for line in (content .. "\n"):gmatch("([^\n]*)\n") do
        table.insert(lines, line)
    end
    -- Remove trailing empty line if content ends with newline
    if #lines > 0 and lines[#lines] == "" and content:sub(-1) == "\n" then
        table.remove(lines)
    end

    -- Parse into blocks
    local blocks = parse_into_blocks(lines)

    -- Pre-process: recombine previously split tables
    blocks = recombine_split_tables(blocks)

    -- Process blocks
    local output_lines = {}

    for _, block in ipairs(blocks) do
        if block.type == "code" or block.type == "header" or block.type == "blank" then
            for _, line in ipairs(block.lines) do
                table.insert(output_lines, line)
            end
        elseif block.type == "table" then
            local formatted = process_table(block.lines, config)
            for _, line in ipairs(formatted) do
                table.insert(output_lines, line)
            end
        elseif block.type == "paragraph" then
            local wrapped = wrap_paragraph(block, config.line_width)
            for _, line in ipairs(wrapped) do
                table.insert(output_lines, line)
            end
        elseif block.type == "list_item" then
            local wrapped = wrap_list_item(block, config.line_width)
            for _, line in ipairs(wrapped) do
                table.insert(output_lines, line)
            end
        end
    end

    -- Write back
    f = io.open(full_path, "w")
    if not f then
        return false, "Cannot write to file: " .. full_path
    end

    local final_content = table.concat(output_lines, "\n") .. "\n"
    f:write(final_content)
    f:close()

    local final_size = #final_content
    local final_lines = #output_lines

    return true, full_path, {
        original_lines = original_lines,
        final_lines = final_lines,
        original_bytes = original_size,
        final_bytes = final_size,
        line_width = config.line_width
    }
end

-- Main function - supports both CLI and LLM tool modes
local function main()
    local file_path = nil
    local project_dir = "./"
    local is_tool_mode = false

    -- Check if we have CLI arguments
    if #arg >= 1 and arg[1] ~= "" then
        -- CLI mode: ./lint_docs <file_path>
        file_path = arg[1]
    else
        -- LLM tool mode: read JSON from stdin
        local input = io.read("*a")
        if input and input ~= "" then
            local params, pos, err = json.decode(input)
            if params then
                is_tool_mode = true
                file_path = params.filename
                project_dir = params._project_dir or "./"
            else
                print(json.encode({success = false, error = "Invalid JSON input: " .. tostring(err)}))
                os.exit(1)
            end
        end
    end

    -- Validate we have a file path
    if not file_path or file_path == "" then
        if is_tool_mode then
            print(json.encode({success = false, error = "Missing required parameter: filename"}))
        else
            io.stderr:write("Usage: lint_docs <file_path>\n")
            io.stderr:write("   or: echo '{\"filename\": \"doc.md\"}' | lint_docs\n")
        end
        os.exit(1)
    end

    -- Run the linter
    local success, result, stats = lint_file(file_path, project_dir)

    if is_tool_mode then
        -- JSON output for LLM
        if success then
            print(json.encode({
                success = true,
                message = string.format("Linted %s: %d lines (%d bytes), line width: %d",
                    result, stats.final_lines, stats.final_bytes, stats.line_width),
                file = result,
                stats = stats
            }))
        else
            print(json.encode({success = false, error = result}))
        end
    else
        -- Human-readable output for CLI
        if success then
            print(string.format("Linted: %s (%d lines, %d bytes, width: %d)",
                result, stats.final_lines, stats.final_bytes, stats.line_width))
        else
            io.stderr:write("Error: " .. result .. "\n")
            os.exit(1)
        end
    end
end

main()
